<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Querying Solutions · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="JuMP logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuMP</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installation Guide</a></li><li><a class="tocitem" href="../quickstart/">Quick Start Guide</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../expressions/">Expressions</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../containers/">Containers</a></li><li><a class="tocitem" href="../solvers/">Interacting with solvers</a></li><li class="is-active"><a class="tocitem" href>Querying Solutions</a><ul class="internal"><li><a class="tocitem" href="#Termination-statuses"><span>Termination statuses</span></a></li><li><a class="tocitem" href="#Solution-statuses"><span>Solution statuses</span></a></li><li><a class="tocitem" href="#Obtaining-solutions"><span>Obtaining solutions</span></a></li><li><a class="tocitem" href="#Accessing-MathOptInterface-attributes"><span>Accessing MathOptInterface attributes</span></a></li><li><a class="tocitem" href="#Sensitivity-analysis-for-LP"><span>Sensitivity analysis for LP</span></a></li><li><a class="tocitem" href="#Conflicts"><span>Conflicts</span></a></li><li><a class="tocitem" href="#Multiple-solutions"><span>Multiple solutions</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/basic/">A basic example</a></li><li><a class="tocitem" href="../examples/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../examples/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../examples/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../examples/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../examples/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../examples/cutting_stock_column_generation/">Cutting stock</a></li><li><a class="tocitem" href="../examples/diet/">The diet problem</a></li><li><a class="tocitem" href="../examples/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../examples/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../examples/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../examples/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../examples/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../examples/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../examples/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../examples/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../examples/qcp/">Quadratically constrained programs</a></li><li><a class="tocitem" href="../examples/robust_uncertainty/">Robust uncertainty sets</a></li><li><a class="tocitem" href="../examples/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../examples/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../examples/sudoku/">Solving Sudokus with MIP</a></li><li><a class="tocitem" href="../examples/transp/">The transportation problem</a></li><li><a class="tocitem" href="../examples/urban_plan/">The urban planning problem</a></li></ul></li><li><a class="tocitem" href="../style/">Style Guide</a></li><li><a class="tocitem" href="../roadmap/">Development Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Querying Solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Querying Solutions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/solutions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Querying-Solutions"><a class="docs-heading-anchor" href="#Querying-Solutions">Querying Solutions</a><a id="Querying-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-Solutions" title="Permalink"></a></h1><p>So far we have seen all the elements and constructs related to writing a JuMP optimization model. In this section we reach the point of what to do with a solved problem. Suppose your model is named <code>model</code>. Right after the call to <code>optimize!(model)</code>, it&#39;s natural to ask JuMP questions about the finished optimization step. Typical questions include:</p><ul><li>Why has the optimization process stopped? Did it hit the time limit or run into numerical issues?</li><li>Do I have a solution to my problem?</li><li>Is it optimal?</li><li>Do I have a dual solution?</li><li>How sensitive is the solution to data perturbations?</li></ul><p>JuMP follows closely the concepts defined in <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface (MOI)</a> to answer user questions about a finished call to <code>optimize!(model)</code>. There are three main steps in querying a solution:</p><p>First, we can query the <a href="#JuMP.termination_status"><code>termination_status</code></a> which will tell us why the optimization stopped. This could be due to a number of reasons. For example, the solver found an optimal solution, the problem was proven to be infeasible, or a user-provided limit such as a time limit was encountered. For more information, see the <a href="#Termination-statuses">Termination statuses</a> section below.</p><p>Second, we can query the <a href="#JuMP.primal_status"><code>primal_status</code></a> and the <a href="#JuMP.dual_status"><code>dual_status</code></a>, which will tell us what kind of results we have for our primal and dual solutions. This might be an optimal primal-dual pair, a primal solution without a corresponding dual solution, or a certificate of primal or dual infeasibility. For more information, see the <a href="#Solution-statuses">Solution statuses</a> section below.</p><p>Third, we can query <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.dual"><code>dual</code></a> to obtain the primal and dual values of the optimization variables and constraints (if there are values to be queried).</p><h2 id="Termination-statuses"><a class="docs-heading-anchor" href="#Termination-statuses">Termination statuses</a><a id="Termination-statuses-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-statuses" title="Permalink"></a></h2><p>The reason why the optimization of <code>model</code> was finished is given by</p><pre><code class="language-julia">termination_status(model)</code></pre><p>This function will return a <code>MOI.TerminationStatusCode</code> <code>enum</code>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorithm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L78">source</a></section></article><p>Additionally, we can receive a solver specific string explaining why the optimization stopped with <a href="#JuMP.raw_status"><code>raw_status</code></a>.</p><h2 id="Solution-statuses"><a class="docs-heading-anchor" href="#Solution-statuses">Solution statuses</a><a id="Solution-statuses-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-statuses" title="Permalink"></a></h2><p>These statuses indicate what kind of result is available to be queried with <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.dual"><code>dual</code></a>. It&#39;s possible that no result is available to be queried.</p><p>We can obtain these statuses by calling <a href="#JuMP.primal_status"><code>primal_status</code></a> for the primal status, and <a href="#JuMP.dual_status"><code>dual_status</code></a> for the dual status. Both will return a <code>MOI.ResultStatusCode</code> <code>enum</code>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>REDUCTION_CERTIFICATE</code>: the result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a> for details. If the <code>PrimalStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the primal result vector is a proof that the dual problem is ill-posed. If the <code>DualStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the dual result vector is a proof that the primal is ill-posed.</li><li><code>NEARLY_REDUCTION_CERTIFICATE</code>: the result satisfies a relaxed criterion for an ill-posed certificate.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L30">source</a></section></article><p>Common status situations are described in the <a href="https://jump.dev/MathOptInterface.jl/v0.9.1/apimanual/#Common-status-situations-1">MOI docs</a>.</p><h2 id="Obtaining-solutions"><a class="docs-heading-anchor" href="#Obtaining-solutions">Obtaining solutions</a><a id="Obtaining-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-solutions" title="Permalink"></a></h2><p>Provided the primal status is not <code>MOI.NO_SOLUTION</code>, the primal solution can be obtained by calling <a href="#JuMP.value"><code>value</code></a>. For the dual solution, the function is <a href="#JuMP.dual"><code>dual</code></a>. Calling <a href="#JuMP.has_values"><code>has_values</code></a> for the primal status and <a href="#JuMP.has_duals"><code>has_duals</code></a> for the dual solution is an equivalent way to check whether the status is <code>MOI.NO_SOLUTION</code>.</p><p>It is important to note that if <a href="#JuMP.has_values"><code>has_values</code></a> or <a href="#JuMP.has_duals"><code>has_duals</code></a> return false, calls to <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.dual"><code>dual</code></a> might throw an error or return arbitrary values.</p><p>The container type (e.g., scalar, vector, or matrix) of the returned solution (primal or dual) depends on the type of the variable or constraint. See <a href="../extensions/#JuMP.AbstractShape"><code>AbstractShape</code></a> and <a href="../extensions/#JuMP.dual_shape"><code>dual_shape</code></a> for details.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To call <a href="#JuMP.value"><code>value</code></a> or <a href="#JuMP.dual"><code>dual</code></a> on containers of <a href="../variables/#JuMP.VariableRef"><code>VariableRef</code></a> or <a href="../constraints/#JuMP.ConstraintRef"><code>ConstraintRef</code></a>, use the broadcast syntax, e.g., <code>value.(x)</code>.</p></div></div><p>The objective value of a solved problem can be obtained via <a href="../objective/#JuMP.objective_value"><code>objective_value</code></a>. The best known bound on the optimal objective value can be obtained via <a href="../objective/#JuMP.objective_bound"><code>objective_bound</code></a>. If the solver supports it, the value of the dual objective can be obtained via <a href="../objective/#JuMP.dual_objective_value"><code>dual_objective_value</code></a>.</p><p>The following is a recommended workflow for solving a model and querying the solution:</p><pre><code class="language-julia">using JuMP
model = Model()
@variable(model, x[1:10] &gt;= 0)
# ... other constraints ...
optimize!(model)

if termination_status(model) == MOI.OPTIMAL
    optimal_solution = value.(x)
    optimal_objective = objective_value(model)
elseif termination_status(model) == MOI.TIME_LIMIT &amp;&amp; has_values(model)
    suboptimal_solution = value.(x)
    suboptimal_objective = objective_value(model)
else
    error(&quot;The model was not solved correctly.&quot;)
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Querying after modification</header><div class="admonition-body"><p>If a solved model is modified, then querying the solution is undefined behavior. Adding, deleting, or modifying a constraint (or variable) may invalidate any part of the solution.</p></div></div><h2 id="Accessing-MathOptInterface-attributes"><a class="docs-heading-anchor" href="#Accessing-MathOptInterface-attributes">Accessing MathOptInterface attributes</a><a id="Accessing-MathOptInterface-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-MathOptInterface-attributes" title="Permalink"></a></h2><p><a href="https://jump.dev/MathOptInterface.jl/v0.9.10/">MathOptInterface</a> defines a large number of model attributes that can be queried. Examples include <a href="https://jump.dev/MathOptInterface.jl/v0.9.10/apireference/#MathOptInterface.RelativeGap"><code>MOI.RelativeGap</code></a> and <a href="https://jump.dev/MathOptInterface.jl/v0.9.10/apireference/#MathOptInterface.SimplexIterations"><code>MOI.SimplexIterations</code></a>.</p><p>Some attributes can be directly accessed by getter functions. These include</p><ul><li><a href="../objective/#JuMP.objective_bound"><code>objective_bound</code></a></li><li><a href="#JuMP.relative_gap"><code>relative_gap</code></a></li><li><a href="#JuMP.simplex_iterations"><code>simplex_iterations</code></a></li><li><a href="#JuMP.barrier_iterations"><code>barrier_iterations</code></a></li><li><a href="#JuMP.node_count"><code>node_count</code></a></li></ul><p>To query these attributes, use:</p><pre><code class="language-julia">using JuMP
model = Model()
# ...
optimize!(model)

@show relative_gap(model)
# or
@show MOI.get(model, MOI.RelativeGap())

@show simplex_iterations(model)
# or
@show MOI.get(model, MOI.SimplexIterations())</code></pre><h2 id="Sensitivity-analysis-for-LP"><a class="docs-heading-anchor" href="#Sensitivity-analysis-for-LP">Sensitivity analysis for LP</a><a id="Sensitivity-analysis-for-LP-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitivity-analysis-for-LP" title="Permalink"></a></h2><p>Given an LP problem and an optimal solution corresponding to a basis, we can question how much an objective coefficient or standard form rhs coefficient (c.f., <a href="../constraints/#JuMP.normalized_rhs"><code>normalized_rhs</code></a>) can change without violating primal or dual feasibility of the basic solution. Note that not all solvers compute the basis, and for sensitivity analysis, the solver interface must implement <code>MOI.ConstraintBasisStatus</code>.</p><p>Given an LP optimal solution (and both <a href="#JuMP.has_values"><code>has_values</code></a> and <a href="#JuMP.has_duals"><code>has_duals</code></a> returns <code>true</code>) <a href="#JuMP.lp_objective_perturbation_range"><code>lp_objective_perturbation_range</code></a> returns a range of the allowed perturbation of the cost coefficient corresponding to the input variable. Note that the current primal solution remains optimal within this range, however the corresponding dual solution might change since a cost coefficient is perturbed. Similarly, <a href="#JuMP.lp_rhs_perturbation_range"><code>lp_rhs_perturbation_range</code></a> returns a range of the allowed perturbation of the rhs coefficient corresponding to the input constraint. And in this range the current dual solution remains optimal but the primal solution might change since a rhs coefficient is perturbed.</p><p>However, if the problem is degenerate, there are multiple optimal bases and hence these ranges might not be as intuitive and seem too narrow. E.g., a larger cost coefficient perturbation might not invalidate the optimality of the current primal solution. Moreover, if a problem is degenerate, due to finite precision, it can happen that, e.g., a perturbation seems to invalidate a basis even though it doesn&#39;t (again providing too narrow ranges). To prevent this <code>feasibility_tolerance</code> and <code>optimality_tolerance</code> is introduced, which in turn, might make the ranges too wide for numerically challenging instances. Thus do not blindly trust these ranges, especially not for highly degenerate or numerically unstable instances.</p><p>To give a simple example, we could analyze the sensitivity of the optimal solution to the following (non-degenerate) LP problem:</p><pre><code class="language-julia">julia&gt; model = Model();
julia&gt; @variable(model, x[1:2]);
julia&gt; @constraint(model, c1, x[1] + x[2] &lt;= 1);
julia&gt; @constraint(model, c2, x[1] - x[2] &lt;= 1);
julia&gt; @constraint(model, c3, -0.5 &lt;= x[2] &lt;= 0.5);
julia&gt; @objective(model, Max, x[1]);</code></pre><p>To analyze the sensitivity of the problem we could check the allowed perturbation ranges of, e.g., the cost coefficients and the rhs coefficient of constraint <code>c1</code> as follows:</p><pre><code class="language-julia-repl">julia&gt; optimize!(model);

julia&gt; value.(x)
2-element Array{Float64,1}:
 1.0
 0.0
julia&gt; lp_objective_perturbation_range(x[1])
(-1.0, Inf)
julia&gt; lp_objective_perturbation_range(x[2])
(-1.0, 1.0)
julia&gt; lp_rhs_perturbation_range(c1)
(-1.0, 1.0)</code></pre><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_objective_perturbation_range" href="#JuMP.lp_objective_perturbation_range"><code>JuMP.lp_objective_perturbation_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lp_objective_perturbation_range(var::VariableRef;
                                optimality_tolerance::Float64)
                                ::Tuple{Float64, Float64}</code></pre><p>Gives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.</p><p><strong>Notes</strong></p><ul><li>The range denotes valid changes, Δ ∈ [l, u], for which cost[var] += Δ do not violate the current optimality conditions.</li><li><code>optimality_tolerance</code> is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The defualt tolerance should however apply in most situations (c.f. &quot;Computational Techniques of the Simplex Method&quot; by István Maros, section 9.3.4).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/lp_sensitivity.jl#L261-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_rhs_perturbation_range" href="#JuMP.lp_rhs_perturbation_range"><code>JuMP.lp_rhs_perturbation_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lp_rhs_perturbation_range(constraint::ConstraintRef;
                          feasibility_tolerance::Float64)
                          ::Tuple{Float64, Float64}</code></pre><p>Gives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.</p><p><strong>Notes</strong></p><ul><li>The rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x □ b, where □ is ≤, =, or ≥.</li><li>The range denotes valid changes, e.g., for a*x &lt;= b + Δ, the LP basis remains feasible for all Δ ∈ [l, u].</li><li><code>feasibility_tolerance</code> is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. &quot;Computational Techniques of the Simplex Method&quot; by István Maros, section 9.3.4).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/lp_sensitivity.jl#L11-L26">source</a></section></article><h2 id="Conflicts"><a class="docs-heading-anchor" href="#Conflicts">Conflicts</a><a id="Conflicts-1"></a><a class="docs-heading-anchor-permalink" href="#Conflicts" title="Permalink"></a></h2><p>When the model you input is infeasible, some solvers can help you find the  cause of this infeasibility by offering a conflict, i.e., a subset of the  constraints that create this infeasibility. Depending on the solver,  this can also be called an IIS (irreducible inconsistent subsystem). </p><p>The function <a href="#JuMP.compute_conflict!"><code>compute_conflict!</code></a> is used to trigger the computation of a conflict. Once this process is finished, the attribute <a href="#MathOptInterface.ConflictStatus"><code>MOI.ConflictStatus</code></a> returns a <a href="#MathOptInterface.ConflictStatusCode"><code>MOI.ConflictStatusCode</code></a>.</p><p>If there is a conflict, you can query from each constraint whether it  participates in the conflict or not using the attribute <a href="#MathOptInterface.ConstraintConflictStatus"><code>MOI.ConstraintConflictStatus</code></a>, which returns a <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>MOI.ConflictParticipationStatusCode</code></a>.</p><p>For instance, this is how you can use this functionality: </p><pre><code class="language-julia">using JuMP
model = Model() # You must use a solver that supports conflict refining/IIS computation, like CPLEX or Gurobi
@variable(model, x &gt;= 0)
@constraint(model, c1, x &gt;= 2)
@constraint(model, c2, x &lt;= 1)
optimize!(model)

# termination_status(model) will likely be MOI.INFEASIBLE, 
# depending on the solver

compute_conflict!(model)
if MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND
    error(&quot;No conflict could be found for an infeasible model.&quot;)
end

# Both constraints should participate in the conflict.
MOI.get(model, MOI.ConstraintConflictStatus(), c1)
MOI.get(model, MOI.ConstraintConflictStatus(), c2)</code></pre><h2 id="Multiple-solutions"><a class="docs-heading-anchor" href="#Multiple-solutions">Multiple solutions</a><a id="Multiple-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-solutions" title="Permalink"></a></h2><p>Some solvers support returning multiple solutions. You can check how many solutions are available to query using <a href="#JuMP.result_count"><code>result_count</code></a>.</p><p>Functions for querying the solutions, e.g., <a href="#JuMP.primal_status"><code>primal_status</code></a> and <a href="#JuMP.value"><code>value</code></a>, all take an additional keyword argument <code>result</code> which can be used to specify which result to return.</p><pre><code class="language-julia">using JuMP
model = Model()
@variable(model, x[1:10] &gt;= 0)
# ... other constraints ...
optimize!(model)

if termination_status(model) != MOI.OPTIMAL
    error(&quot;The model was not solved correctly.&quot;)
end

num_results = result_count(model)
@assert has_values(model; result = num_results)
an_optimal_solution = value.(x; result = num_results)
an_optimal_objective = objective_value(model; result = num_results)</code></pre><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.termination_status" href="#JuMP.termination_status"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">termination_status(model::Model)</code></pre><p>Return the reason why the solver stopped (i.e., the MathOptInterface model attribute <code>TerminationStatus</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L444-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.raw_status" href="#JuMP.raw_status"><code>JuMP.raw_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">raw_status(model::Model)</code></pre><p>Return the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute <code>RawStatusString</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L454-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_status" href="#JuMP.primal_status"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">primal_status(model::Model; result::Int = 1)</code></pre><p>Return the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute <code>PrimalStatus</code>) associated with the result index <code>result</code>.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L464-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_values" href="#JuMP.has_values"><code>JuMP.has_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_values(model::Model; result::Int = 1)</code></pre><p>Return <code>true</code> if the solver has a primal solution in result index <code>result</code> available to query, otherwise return <code>false</code>.</p><p>See also <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/variables.jl#L779-L786">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value" href="#JuMP.value"><code>JuMP.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">value(con_ref::ConstraintRef; result::Int = 1)</code></pre><p>Return the primal value of constraint <code>con_ref</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>That is, if <code>con_ref</code> is the reference of a constraint <code>func</code>-in-<code>set</code>, it returns the value of <code>func</code> evaluated at the value of the variables (given by <a href="../nlp/#JuMP.value-Tuple{NonlinearParameter}"><code>value(::VariableRef)</code></a>).</p><p>Use <a href="#JuMP.has_values"><code>has_values</code></a> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p><p><strong>Note</strong></p><p>For scalar contraints, the constant is moved to the <code>set</code> so it is not taken into account in the primal value of the constraint. For instance, the constraint <code>@constraint(model, 2x + 3y + 1 == 5)</code> is transformed into <code>2x + 3y</code>-in-<code>MOI.EqualTo(4)</code> so the value returned by this function is the evaluation of <code>2x + 3y</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/constraints.jl#L635-L657">source</a></section><section><div><pre><code class="language-none">value(con_ref::ConstraintRef, var_value::Function)</code></pre><p>Evaluate the primal value of the constraint <code>con_ref</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/constraints.jl#L662-L667">source</a></section><section><div><pre><code class="language-none">value(v::VariableRef; result = 1)</code></pre><p>Return the value of variable <code>v</code> associated with result index <code>result</code> of the most-recent returned by the solver.</p><p>Use <a href="#JuMP.has_values"><code>has_values</code></a> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/variables.jl#L756-L765">source</a></section><section><div><pre><code class="language-none">value(v::VariableRef, var_value::Function)</code></pre><p>Evaluate the value of the variable <code>v</code> as <code>var_value(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/variables.jl#L770-L774">source</a></section><section><div><pre><code class="language-none">value(ex::GenericAffExpr, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/aff_expr.jl#L149-L153">source</a></section><section><div><pre><code class="language-none">value(v::GenericAffExpr; result::Int = 1)</code></pre><p>Return the value of the <code>GenericAffExpr</code> <code>v</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Replaces <code>getvalue</code> for most use cases.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/aff_expr.jl#L331-L340">source</a></section><section><div><pre><code class="language-none">value(v::GenericQuadExpr; result::Int = 1)</code></pre><p>Return the value of the <code>GenericQuadExpr</code> <code>v</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Replaces <code>getvalue</code> for most use cases.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/quad_expr.jl#L454-L463">source</a></section><section><div><pre><code class="language-julia">value(p::NonlinearParameter)</code></pre><p>Return the current value stored in the nonlinear parameter <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model()
@NLparameter(model, p == 10)
value(p)

# output
10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/nlp.jl#L116-L130">source</a></section><section><div><pre><code class="language-none">value(ex::NonlinearExpression, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/nlp.jl#L1639-L1643">source</a></section><section><div><pre><code class="language-none">value(ex::NonlinearExpression; result::Int = 1)</code></pre><p>Return the value of the <code>NonlinearExpression</code> <code>ex</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Replaces <code>getvalue</code> for most use cases.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/nlp.jl#L1717-L1726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_status" href="#JuMP.dual_status"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual_status(model::Model; result::Int = 1)</code></pre><p>Return the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute <code>DualStatus</code>) associated with the result index <code>result</code>.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L477-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_duals" href="#JuMP.has_duals"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_duals(model::Model; result::Int = 1)</code></pre><p>Return <code>true</code> if the solver has a dual solution in result index <code>result</code> available to query, otherwise return <code>false</code>.</p><p>See also <a href="#JuMP.dual"><code>dual</code></a>, <a href="../constraints/#JuMP.shadow_price"><code>shadow_price</code></a>, and <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/constraints.jl#L691-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual" href="#JuMP.dual"><code>JuMP.dual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual(con_ref::ConstraintRef; result::Int = 1)</code></pre><p>Return the dual value of constraint <code>con_ref</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Use <code>has_dual</code> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>, <a href="../constraints/#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/constraints.jl#L703-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solve_time" href="#JuMP.solve_time"><code>JuMP.solve_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve_time(model::Model)</code></pre><p>If available, returns the solve time reported by the solver. Returns &quot;ArgumentError: ModelLike of type <code>Solver.Optimizer</code> does not support accessing the attribute MathOptInterface.SolveTime()&quot; if the attribute is not implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L492-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.OptimizeNotCalled" href="#JuMP.OptimizeNotCalled"><code>JuMP.OptimizeNotCalled</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct OptimizeNotCalled &lt;: Exception end</code></pre><p>A result attribute cannot be queried before <a href="../solvers/#JuMP.optimize!"><code>optimize!</code></a> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L819-L823">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Start the solution procedure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.result_count" href="#JuMP.result_count"><code>JuMP.result_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">result_count(model::Model)</code></pre><p>Return the number of results available to query after a call to <a href="../solvers/#JuMP.optimize!"><code>optimize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/optimizer_interface.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.relative_gap" href="#JuMP.relative_gap"><code>JuMP.relative_gap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relative_gap(model::Model)</code></pre><p>Return the final relative optimality gap after a call to <code>optimize!(model)</code>. Exact value depends upon implementation of MathOptInterface.RelativeGap() by the particular solver used for optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/objective.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.simplex_iterations" href="#JuMP.simplex_iterations"><code>JuMP.simplex_iterations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplex_iterations(model::Model)</code></pre><p>Gets the cumulative number of simplex iterations during the most-recent optimization.</p><p>Solvers must implement <code>MOI.SimplexIterations()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L665-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.barrier_iterations" href="#JuMP.barrier_iterations"><code>JuMP.barrier_iterations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">barrier_iterations(model::Model)</code></pre><p>Gets the cumulative number of barrier iterations during the most recent optimization.</p><p>Solvers must implement <code>MOI.BarrierIterations()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L676-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.node_count" href="#JuMP.node_count"><code>JuMP.node_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">node_count(model::Model)</code></pre><p>Gets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.</p><p>Solvers must implement <code>MOI.NodeCount()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/JuMP.jl#L687-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.compute_conflict!" href="#JuMP.compute_conflict!"><code>JuMP.compute_conflict!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_conflict!(model::Model)</code></pre><p>Compute a conflict if the model is infeasible. If an optimizer has not been set yet (see <a href="../solvers/#JuMP.set_optimizer"><code>set_optimizer</code></a>), a <a href="../solvers/#JuMP.NoOptimizer"><code>NoOptimizer</code></a> error is thrown.</p><p>The status of the conflict can be checked with the <code>MOI.ConflictStatus</code> model attribute. Then, the status for each constraint can be queried with the <code>MOI.ConstraintConflictStatus</code> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/77a0b82bf47f35913cc8cff0c389425948cb4fea/src/optimizer_interface.jl#L146-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.compute_conflict!" href="#MathOptInterface.compute_conflict!"><code>MathOptInterface.compute_conflict!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_conflict!(optimizer::AbstractOptimizer)</code></pre><p>Computes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.</p><p>Some solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).</p><p>See also <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> and <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a>.</p><p><strong>Note</strong></p><p>If the model is modified after a call to <code>compute_conflict!</code>, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatus" href="#MathOptInterface.ConflictStatus"><code>MathOptInterface.ConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatus()</code></pre><p>A model attribute for the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> explaining why the conflict refiner stopped when computing the conflict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatusCode" href="#MathOptInterface.ConflictStatusCode"><code>MathOptInterface.ConflictStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatusCode</code></pre><p>An Enum of possible values for the <code>ConflictStatus</code> attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a>.</p><p>Possible values are:</p><ul><li><code>COMPUTE_CONFLICT_NOT_CALLED</code>: the function <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a> has not yet been called</li><li><code>NO_CONFLICT_EXISTS</code>: there is no conflict because the problem is feasible</li><li><code>NO_CONFLICT_FOUND</code>: the solver could not find a conflict</li><li><code>CONFLICT_FOUND</code>: at least one conflict could be found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintConflictStatus" href="#MathOptInterface.ConstraintConflictStatus"><code>MathOptInterface.ConstraintConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintConflictStatus()</code></pre><p>A constraint attribute indicating whether the constraint participates in the conflict. Its type is <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictParticipationStatusCode" href="#MathOptInterface.ConflictParticipationStatusCode"><code>MathOptInterface.ConflictParticipationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictParticipationStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a> attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.</p><p>Possible values are:</p><ul><li><code>NOT_IN_CONFLICT</code>: the constraint does not participate in the conflict</li><li><code>IN_CONFLICT</code>: the constraint participates in the conflict</li><li><code>MAYBE_IN_CONFLICT</code>: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solvers/">« Interacting with solvers</a><a class="docs-footer-nextpage" href="../nlp/">Nonlinear Modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 29 November 2020 21:13">Sunday 29 November 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
