<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mixed-integer linear programs · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuMP logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuMP</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/">Installation Guide</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start Guide</a></li><li><a class="tocitem" href="../../variables/">Variables</a></li><li><a class="tocitem" href="../../expressions/">Expressions</a></li><li><a class="tocitem" href="../../objective/">Objectives</a></li><li><a class="tocitem" href="../../constraints/">Constraints</a></li><li><a class="tocitem" href="../../containers/">Containers</a></li><li><a class="tocitem" href="../../solvers/">Interacting with solvers</a></li><li><a class="tocitem" href="../../solutions/">Querying Solutions</a></li><li><a class="tocitem" href="../../nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/callbacks/">Callback API</a></li><li><a class="tocitem" href="../../reference/constraints/">Constraint API</a></li><li><a class="tocitem" href="../../reference/containers/">Containers API</a></li><li><a class="tocitem" href="../../reference/expressions/">Expression API</a></li><li><a class="tocitem" href="../../reference/models/">Model API</a></li><li><a class="tocitem" href="../../reference/moi/">MathOptInterface API</a></li><li><a class="tocitem" href="../../reference/nonlinear/">Nonlinear API</a></li><li><a class="tocitem" href="../../reference/objectives/">Objective API</a></li><li><a class="tocitem" href="../../reference/solutions/">Solution API</a></li><li><a class="tocitem" href="../../reference/variables/">Variable API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../basic/">A basic example</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../cutting_stock_column_generation/">Cutting stock column generation</a></li><li class="is-active"><a class="tocitem" href>Mixed-integer linear programs</a><ul class="internal"><li><a class="tocitem" href="#The-cannery-problem"><span>The cannery problem</span></a></li><li class="toplevel"><a class="tocitem" href="#The-diet-problem"><span>The diet problem</span></a></li><li><a class="tocitem" href="#The-knapsack-problem"><span>The knapsack problem</span></a></li><li><a class="tocitem" href="#The-SteelT3-problem"><span>The SteelT3 problem</span></a></li><li><a class="tocitem" href="#The-transportation-problem"><span>The transportation problem</span></a></li><li><a class="tocitem" href="#The-urban-planning-problem"><span>The urban planning problem</span></a></li><li><a class="tocitem" href="#The-factory-schedule-example"><span>The factory schedule example</span></a></li><li><a class="tocitem" href="#The-multi-commodity-flow-problem"><span>The multi-commodity flow problem</span></a></li><li><a class="tocitem" href="#The-workforce-scheduling-problem"><span>The workforce scheduling problem</span></a></li><li><a class="tocitem" href="#Solving-Sudokus-with-MIP"><span>Solving Sudokus with MIP</span></a></li></ul></li><li><a class="tocitem" href="../nlp_tricks/">Nonlinear tips and tricks</a></li><li><a class="tocitem" href="../nonlinear-programs/">Nonlinear programs</a></li><li><a class="tocitem" href="../quadratic-programs/">Quadratic programs</a></li><li><a class="tocitem" href="../semi-definite-programs/">Semi-definite programs</a></li></ul></li><li><a class="tocitem" href="../../style/">Style Guide</a></li><li><a class="tocitem" href="../../roadmap/">Development Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Mixed-integer linear programs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mixed-integer linear programs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/mixed-integer-linear-programs.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mixed-integer-linear-programs"><a class="docs-heading-anchor" href="#Mixed-integer-linear-programs">Mixed-integer linear programs</a><a id="Mixed-integer-linear-programs-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-integer-linear-programs" title="Permalink"></a></h1><p>These examples use the following packages:</p><pre><code class="language-julia">using JuMP
import GLPK
import Test</code></pre><h2 id="The-cannery-problem"><a class="docs-heading-anchor" href="#The-cannery-problem">The cannery problem</a><a id="The-cannery-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-cannery-problem" title="Permalink"></a></h2><p>A JuMP implementation of the cannery problem from:</p><p>Dantzig, Linear Programming and Extensions, Princeton University Press, Princeton, NJ, 1963.</p><p>It was originally contributed by Louis Luangkesorn, January 30, 2015.</p><pre><code class="language-julia">function example_cannery()
    # Origin plants.
    plants = [&quot;Seattle&quot;, &quot;San-Diego&quot;]
    num_plants = length(plants)
    # Destination markets.
    markets = [&quot;New-York&quot;, &quot;Chicago&quot;, &quot;Topeka&quot;]
    num_markets = length(markets)
    # Capacity and demand in cases.
    capacity = [350, 600]
    demand = [300, 300, 300]
    # Distance in thousand miles.
    distance = [2.5 1.7 1.8; 2.5 1.8 1.4]
    # Cost per case per thousand miles.
    freight = 90
    cannery = Model()
    set_optimizer(cannery, GLPK.Optimizer)
    # Create decision variables.
    @variable(cannery, ship[1:num_plants, 1:num_markets] &gt;= 0)
    # Ship no more than plant capacity
    @constraint(
        cannery, capacity_con[i = 1:num_plants], sum(ship[i, :]) &lt;= capacity[i]
    )
    # Ship at least market demand
    @constraint(
        cannery, demand_con[j = 1:num_markets], sum(ship[:, j]) &gt;= demand[j]
    )
    # Minimize transporatation cost
    @objective(
        cannery,
        Min,
        sum(
            distance[i, j] * freight * ship[i, j]
            for i = 1:num_plants, j = 1:num_markets
        )
    )
    optimize!(cannery)
    println(&quot;RESULTS:&quot;)
    for i = 1:num_plants
        for j = 1:num_markets
            println(&quot;  $(plants[i]) $(markets[j]) = $(value(ship[i, j]))&quot;)
        end
    end
    return
end

example_cannery()</code></pre><pre class="documenter-example-output">RESULTS:
  Seattle New-York = 50.0
  Seattle Chicago = 300.0
  Seattle Topeka = 0.0
  San-Diego New-York = 250.0
  San-Diego Chicago = 0.0
  San-Diego Topeka = 300.0</pre><h1 id="The-diet-problem"><a class="docs-heading-anchor" href="#The-diet-problem">The diet problem</a><a id="The-diet-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-diet-problem" title="Permalink"></a></h1><p>Solve the classic &quot;diet problem&quot;. Based on an <a href="https://www.gurobi.com/documentation/9.0/examples/diet_cpp_cpp.html">example from Gurobi</a>.</p><pre><code class="language-julia">function example_diet(; verbose = true)
    function print_solution(is_optimal, foods, buy)
        println(&quot;RESULTS:&quot;)
        if is_optimal
            for food in foods
                println(&quot;  $(food) = $(value(buy[food]))&quot;)
            end
        else
            println(&quot;The solver did not find an optimal solution.&quot;)
        end
    end

    # Nutrition guidelines
    categories = [&quot;calories&quot;, &quot;protein&quot;, &quot;fat&quot;, &quot;sodium&quot;]
    category_data = Containers.DenseAxisArray([
        1800 2200;
        91   Inf;
        0    65;
        0    1779
        ], categories, [&quot;min&quot;, &quot;max&quot;]
    )
    Test.@test category_data[&quot;protein&quot;, &quot;min&quot;] == 91.0
    Test.@test category_data[&quot;sodium&quot;, &quot;max&quot;] == 1779.0
    # Foods
    foods = [
        &quot;hamburger&quot;, &quot;chicken&quot;, &quot;hot dog&quot;, &quot;fries&quot;, &quot;macaroni&quot;, &quot;pizza&quot;,
        &quot;salad&quot;, &quot;milk&quot;, &quot;ice cream&quot;,
    ]
    cost = Containers.DenseAxisArray(
        [2.49, 2.89, 1.50, 1.89, 2.09, 1.99, 2.49, 0.89, 1.59],
        foods
    )
    food_data = Containers.DenseAxisArray(
        [
            410 24 26 730;
            420 32 10 1190;
            560 20 32 1800;
            380  4 19 270;
            320 12 10 930;
            320 15 12 820;
            320 31 12 1230;
            100  8 2.5 125;
            330  8 10 180
        ], foods, categories
    )
    Test.@test food_data[&quot;hamburger&quot;, &quot;calories&quot;] == 410.0
    Test.@test food_data[&quot;milk&quot;, &quot;fat&quot;] == 2.5
    # Build model
    model = Model(GLPK.Optimizer)
    @variables(model, begin
        # Variables for nutrition info
        category_data[c, &quot;min&quot;] &lt;= nutrition[c = categories] &lt;= category_data[c, &quot;max&quot;]
        # Variables for which foods to buy
        buy[foods] &gt;= 0
    end)
    # Objective - minimize cost
    @objective(model, Min, sum(cost[f] * buy[f] for f in foods))
    # Nutrition constraints
    @constraint(model, [c in categories],
        sum(food_data[f, c] * buy[f] for f in foods) == nutrition[c]
    )
    # Solve
    if verbose
        println(&quot;Solving original problem...&quot;)
    end
    optimize!(model)
    term_status = termination_status(model)
    is_optimal = term_status == MOI.OPTIMAL
    Test.@test primal_status(model) == MOI.FEASIBLE_POINT
    Test.@test objective_value(model) ≈ 11.8288 atol = 1e-4
    if verbose
        print_solution(is_optimal, foods, buy)
    end
    # Limit dairy (note that the problem will become infeasible).
    @constraint(model, buy[&quot;milk&quot;] + buy[&quot;ice cream&quot;] &lt;= 6)
    if verbose
        println(&quot;Solving dairy-limited problem...&quot;)
    end
    optimize!(model)
    Test.@test termination_status(model) == MOI.INFEASIBLE
    Test.@test primal_status(model) == MOI.NO_SOLUTION
    if verbose
        print_solution(false, foods, buy)
    end
    return
end

example_diet()</code></pre><pre class="documenter-example-output">Solving original problem...
RESULTS:
  hamburger = 0.6045138888888888
  chicken = 0.0
  hot dog = 0.0
  fries = 0.0
  macaroni = 0.0
  pizza = 0.0
  salad = 0.0
  milk = 6.9701388888888935
  ice cream = 2.591319444444441
Solving dairy-limited problem...
RESULTS:
The solver did not find an optimal solution.</pre><h2 id="The-knapsack-problem"><a class="docs-heading-anchor" href="#The-knapsack-problem">The knapsack problem</a><a id="The-knapsack-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-knapsack-problem" title="Permalink"></a></h2><p>Formulate and solve a simple knapsack problem:</p><pre><code class="language-none">max sum(p_j x_j)
 st sum(w_j x_j) &lt;= C
    x binary</code></pre><pre><code class="language-julia">function example_knapsack(; verbose = true)
    profit = [5, 3, 2, 7, 4]
    weight = [2, 8, 4, 2, 5]
    capacity = 10
    model = Model(GLPK.Optimizer)
    @variable(model, x[1:5], Bin)
    # Objective: maximize profit
    @objective(model, Max, profit&#39; * x)
    # Constraint: can carry all
    @constraint(model, weight&#39; * x &lt;= capacity)
    # Solve problem using MIP solver
    optimize!(model)
    if verbose
        println(&quot;Objective is: &quot;, objective_value(model))
        println(&quot;Solution is:&quot;)
        for i in 1:5
            print(&quot;x[$i] = &quot;, value(x[i]))
            println(&quot;, p[$i]/w[$i] = &quot;, profit[i] / weight[i])
        end
    end
    Test.@test termination_status(model) == MOI.OPTIMAL
    Test.@test primal_status(model) == MOI.FEASIBLE_POINT
    Test.@test objective_value(model) == 16.0
    return
end

example_knapsack()</code></pre><pre class="documenter-example-output">Objective is: 16.0
Solution is:
x[1] = 1.0, p[1]/w[1] = 2.5
x[2] = 0.0, p[2]/w[2] = 0.375
x[3] = 0.0, p[3]/w[3] = 0.5
x[4] = 1.0, p[4]/w[4] = 3.5
x[5] = 1.0, p[5]/w[5] = 0.8</pre><h2 id="The-SteelT3-problem"><a class="docs-heading-anchor" href="#The-SteelT3-problem">The SteelT3 problem</a><a id="The-SteelT3-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-SteelT3-problem" title="Permalink"></a></h2><p>The steelT3 model from AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan.</p><p>Originally contributed by Louis Luangkesorn, April 3, 2015.</p><pre><code class="language-julia">function example_steelT3(; verbose = true)
    T = 4
    prod = [&quot;bands&quot;, &quot;coils&quot;]
    area = Dict(
        &quot;bands&quot; =&gt; (&quot;east&quot;, &quot;north&quot;),
        &quot;coils&quot; =&gt; (&quot;east&quot;, &quot;west&quot;, &quot;export&quot;)
    )
    avail = [40, 40, 32, 40]
    rate = Dict(&quot;bands&quot; =&gt; 200, &quot;coils&quot; =&gt; 140)
    inv0 = Dict(&quot;bands&quot; =&gt; 10, &quot;coils&quot; =&gt; 0)
    prodcost = Dict(&quot;bands&quot; =&gt; 10, &quot;coils&quot; =&gt; 11)
    invcost = Dict(&quot;bands&quot; =&gt; 2.5, &quot;coils&quot; =&gt; 3)
    revenue = Dict(
        &quot;bands&quot; =&gt; Dict(
            &quot;east&quot; =&gt; [25.0, 26.0, 27.0, 27.0],
            &quot;north&quot; =&gt; [26.5, 27.5, 28.0, 28.5],
        ),
        &quot;coils&quot; =&gt; Dict(
            &quot;east&quot; =&gt;[30, 35, 37, 39],
            &quot;west&quot; =&gt; [29, 32, 33, 35],
            &quot;export&quot; =&gt; [25, 25, 25, 28],
        )
    )
    market = Dict(
        &quot;bands&quot; =&gt; Dict(
            &quot;east&quot; =&gt; [2000, 2000, 1500, 2000],
            &quot;north&quot; =&gt; [4000, 4000, 2500, 4500],
        ),
        &quot;coils&quot; =&gt; Dict(
            &quot;east&quot; =&gt; [1000, 800, 1000, 1100],
            &quot;west&quot; =&gt; [2000, 1200, 2000, 2300],
            &quot;export&quot; =&gt; [1000, 500, 500, 800],
        )
    )
    # Model
    model = Model(GLPK.Optimizer)
    # Decision Variables
    @variables(model, begin
        make[p in prod, t in 1:T] &gt;= 0
        inventory[p in prod, t in 0:T] &gt;= 0
        0 &lt;= sell[p in prod, a in area[p], t in 1:T] &lt;= market[p][a][t]
    end)
    @constraints(model, begin
        [p = prod, a = area[p], t = 1:T], sell[p, a, t] &lt;= market[p][a][t]
        # Total of hours used by all products may not exceed hours available,
        # in each week
        [t in 1:T], sum(1 / rate[p] * make[p, t] for p in prod) &lt;= avail[t]
        # Initial inventory must equal given value
        [p in prod], inventory[p, 0] == inv0[p]
        # Tons produced and taken from inventory must equal tons sold and put
        # into inventory.
        [p in prod, t in 1:T], make[p, t] + inventory[p, t - 1] == sum(sell[p, a, t] for a in area[p]) + inventory[p, t]
    end)
    # Maximize total profit: total revenue less costs for all products in all
    # weeks.
    @objective(
        model,
        Max,
        sum(
            revenue[p][a][t] * sell[p, a, t] -
            prodcost[p] * make[p, t] -
            invcost[p] * inventory[p, t]
            for p in prod, a in area[p], t in 1:T
        )
    )
    optimize!(model)
    Test.@test termination_status(model) == MOI.OPTIMAL
    Test.@test primal_status(model) == MOI.FEASIBLE_POINT
    Test.@test objective_value(model) == 172850.0
    if verbose
        println(&quot;RESULTS:&quot;)
        for p in prod
            println(&quot;make $(p)&quot;)
            for t in 1:T
                print(value(make[p, t]), &quot;\t&quot;)
            end
            println()
            println(&quot;Inventory $(p)&quot;)
            for t in 1:T
                print(value(inventory[p, t]), &quot;\t&quot;)
            end
            println()
            for a in area[p]
                println(&quot;sell $(p) $(a)&quot;)
            for t in 1:T
                print(value(sell[p, a, t]), &quot;\t&quot;)
            end
            println()
            end
        end
    end
    return
end

example_steelT3()</code></pre><pre class="documenter-example-output">RESULTS:
make bands
5990.0	6000.0	4000.0	6500.0
Inventory bands
0.0	0.0	0.0	0.0
sell bands east
2000.0	2000.0	1500.0	2000.0
sell bands north
4000.0	4000.0	2500.0	4500.0
make coils
0.0	800.0	1000.0	1050.0
Inventory coils
0.0	0.0	0.0	0.0
sell coils east
0.0	800.0	1000.0	1050.0
sell coils west
0.0	0.0	0.0	0.0
sell coils export
0.0	0.0	0.0	0.0</pre><h2 id="The-transportation-problem"><a class="docs-heading-anchor" href="#The-transportation-problem">The transportation problem</a><a id="The-transportation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-transportation-problem" title="Permalink"></a></h2><p>Allocation of passenger cars to trains to minimize cars required or car-miles run. Based on:</p><p>Fourer, D.M. Gay and Brian W. Kernighan, A Modeling Language for Mathematical Programming, https://ampl.com/REFS/amplmod.ps.gz Appendix D.</p><p>Originally contributed by Louis Luangkesorn, January 30, 2015.</p><pre><code class="language-julia">function example_transp()
    ORIG = [&quot;GARY&quot;, &quot;CLEV&quot;, &quot;PITT&quot;]
    DEST = [&quot;FRA&quot;, &quot;DET&quot;, &quot;LAN&quot;, &quot;WIN&quot;, &quot;STL&quot;, &quot;FRE&quot;, &quot;LAF&quot;]
    supply = [1_400, 2_600, 2_900]
    demand = [900, 1_200, 600, 400, 1_700, 1_100, 1_000]
    Test.@test sum(supply) == sum(demand)
    cost = [
        39   14   11   14   16   82    8;
        27    9   12    9   26   95   17;
        24   14   17   13   28   99   20
    ]
    model = Model(GLPK.Optimizer)
    @variable(model, trans[1:length(ORIG), 1:length(DEST)] &gt;= 0)
    @objective(
        model,
        Min,
        sum(
            cost[i, j] * trans[i, j]
            for i in 1:length(ORIG), j in 1:length(DEST)
        )
    )
    @constraints(model, begin
        [i in 1:length(ORIG)], sum(trans[i, :]) == supply[i]
        [j in 1:length(DEST)], sum(trans[:, j]) == demand[j]
    end)
    optimize!(model)
    Test.@test termination_status(model) == MOI.OPTIMAL
    Test.@test primal_status(model) == MOI.FEASIBLE_POINT
    Test.@test objective_value(model) == 196200.0
    println(&quot;The optimal solution is:&quot;)
    println(value.(trans))
    return
end

example_transp()</code></pre><pre class="documenter-example-output">The optimal solution is:
[0.0 0.0 0.0 0.0 300.0 1100.0 0.0; 0.0 1200.0 600.0 400.0 0.0 0.0 400.0; 900.0 0.0 0.0 0.0 1400.0 0.0 600.0]</pre><h2 id="The-urban-planning-problem"><a class="docs-heading-anchor" href="#The-urban-planning-problem">The urban planning problem</a><a id="The-urban-planning-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-urban-planning-problem" title="Permalink"></a></h2><p>An &quot;urban planning&quot; problem based on an <a href="http://www.puzzlor.com/2013-08_UrbanPlanning.html">example from puzzlor</a>.</p><pre><code class="language-julia">function example_urban_plan()
    model = Model(GLPK.Optimizer)
    # x is indexed by row and column
    @variable(model, 0 &lt;= x[1:5, 1:5] &lt;= 1, Int)
    # y is indexed by R or C, the points, and an index in 1:5. Note how JuMP
    # allows indexing on arbitrary sets.
    rowcol = [&quot;R&quot;, &quot;C&quot;]
    points = [5, 4, 3, -3, -4, -5]
    @variable(model, 0 &lt;= y[rowcol, points, 1:5] &lt;= 1, Int)
    # Objective - combine the positive and negative parts
    @objective(model, Max, sum(
          3 * (y[&quot;R&quot;, 3, i] + y[&quot;C&quot;, 3, i])
        + 1 * (y[&quot;R&quot;, 4, i] + y[&quot;C&quot;, 4, i])
        + 1 * (y[&quot;R&quot;, 5, i] + y[&quot;C&quot;, 5, i])
        - 3 * (y[&quot;R&quot;, -3, i] + y[&quot;C&quot;, -3, i])
        - 1 * (y[&quot;R&quot;, -4, i] + y[&quot;C&quot;, -4, i])
        - 1 * (y[&quot;R&quot;, -5, i] + y[&quot;C&quot;, -5, i])
        for i in 1:5)
    )
    # Constrain the number of residential lots
    @constraint(model, sum(x) == 12)
    # Add the constraints that link the auxiliary y variables to the x variables
    for i = 1:5
        @constraints(model, begin
            # Rows
            y[&quot;R&quot;, 5, i] &lt;= 1 / 5 * sum(x[i, :]) # sum = 5
            y[&quot;R&quot;, 4, i] &lt;= 1 / 4 * sum(x[i, :]) # sum = 4
            y[&quot;R&quot;, 3, i] &lt;= 1 / 3 * sum(x[i, :]) # sum = 3
            y[&quot;R&quot;, -3, i] &gt;= 1 - 1 / 3 * sum(x[i, :]) # sum = 2
            y[&quot;R&quot;, -4, i] &gt;= 1 - 1 / 2 * sum(x[i, :]) # sum = 1
            y[&quot;R&quot;, -5, i] &gt;= 1 - 1 / 1 * sum(x[i, :]) # sum = 0
            # Columns
            y[&quot;C&quot;, 5, i] &lt;= 1 / 5 * sum(x[:, i]) # sum = 5
            y[&quot;C&quot;, 4, i] &lt;= 1 / 4 * sum(x[:, i]) # sum = 4
            y[&quot;C&quot;, 3, i] &lt;= 1 / 3 * sum(x[:, i]) # sum = 3
            y[&quot;C&quot;, -3, i] &gt;= 1 - 1 / 3 * sum(x[:, i]) # sum = 2
            y[&quot;C&quot;, -4, i] &gt;= 1 - 1 / 2 * sum(x[:, i]) # sum = 1
            y[&quot;C&quot;, -5, i] &gt;= 1 - 1 / 1 * sum(x[:, i]) # sum = 0
        end)
    end
    # Solve it
    optimize!(model)
    Test.@test termination_status(model) == MOI.OPTIMAL
    Test.@test primal_status(model) == MOI.FEASIBLE_POINT
    Test.@test objective_value(model) ≈ 14.0
    return
end

example_urban_plan()</code></pre><h2 id="The-factory-schedule-example"><a class="docs-heading-anchor" href="#The-factory-schedule-example">The factory schedule example</a><a id="The-factory-schedule-example-1"></a><a class="docs-heading-anchor-permalink" href="#The-factory-schedule-example" title="Permalink"></a></h2><p>This is a Julia translation of part 5 from &quot;Introduction to to Linear Programming with Python&quot; available at https://github.com/benalexkeen/Introduction-to-linear-programming</p><p>For 2 factories (A, B), minimize the cost of production over the course of 12 months while meeting monthly demand. Factory B has a planned outage during month 5.</p><p>It was originally contributed by @Crghilardi.</p><pre><code class="language-julia">function example_factory_schedule()
   # Sets in the problem:
   months, factories = 1:12, [:A, :B]
   # This function takes a matrix and converts it to a JuMP container so we can
   # refer to elements such as `d_max_cap[1, :A]`.
   containerize(A::Matrix) = Containers.DenseAxisArray(A, months, factories)
   # Maximum production capacity in (month, factory) [units/month]:
   d_max_cap = containerize([
         100000	50000;
         110000	55000;
         120000	60000;
         145000	100000;
         160000	0;
         140000	70000;
         155000	60000;
         200000	100000;
         210000	100000;
         197000	100000;
         80000	120000;
         150000	150000;
   ])
   # Minimum production capacity in (month, factory) [units/month]:
   d_min_cap = containerize([
         20000	20000;
         20000	20000;
         20000	20000;
         20000	20000;
         20000	0;
         20000	20000;
         20000	20000;
         20000	20000;
         20000	20000;
         20000	20000;
         20000	20000;
         20000	20000;
   ])
   # Variable cost of production in (month, factory) [$/unit]:
   d_var_cost = containerize([
         10	5;
         11	4;
         12	3;
         9	5;
         8	0;
         8	6;
         5	4;
         7	6;
         9	8;
         10	11;
         8	10;
         8	12
   ])
   # Fixed cost of production in (month, factory) # [$/month]:
   d_fixed_cost = containerize([
         500	600;
         500	600;
         500	600;
         500	600;
         500	0;
         500	600;
         500	600;
         500	600;
         500	600;
         500	600;
         500	600;
         500	600
   ])
   # Demand in each month [units/month]:
   d_demand = [
      120_000,
      100_000,
      130_000,
      130_000,
      140_000,
      130_000,
      150_000,
      170_000,
      200_000,
      190_000,
      140_000,
      100_000,
   ]
   # The model!
   model = Model(GLPK.Optimizer)
   # Decision variables
   @variables(model, begin
      status[m in months, f in factories], Bin
      production[m in months, f in factories], Int
   end)
   # The production cannot be less than minimum capacity.
   @constraint(
      model,
      [m in months, f in factories],
      production[m, f] &gt;= d_min_cap[m, f] * status[m, f],
   )
   # The production cannot be more tha maximum capacity.
   @constraint(
      model,
      [m in months, f in factories],
      production[m, f] &lt;= d_max_cap[m, f] * status[m, f],
   )
   # The production must equal demand in a given month.
   @constraint(model, [m in months], sum(production[m, :]) == d_demand[m])
   # Factory B is shut down during month 5, so production and status are both
   # zero.
   fix(status[5, :B], 0.0)
   fix(production[5, :B], 0.0)
   # The objective is to minimize the cost of production across all time
   ##periods.
   @objective(
      model,
      Min,
      sum(
         d_fixed_cost[m, f] * status[m, f] + d_var_cost[m, f] * production[m, f]
         for m in months, f in factories
      )
   )
   # Optimize the problem
   optimize!(model)
   # Check the solution!
   Test.@testset &quot;Check the solution against known optimal&quot; begin
      Test.@test termination_status(model) == MOI.OPTIMAL
      Test.@test objective_value(model) == 12_906_400.0
      Test.@test value.(production)[1, :A] == 70_000
      Test.@test value.(status)[1, :A] == 1
      Test.@test value.(status)[5, :B] == 0
      Test.@test value.(production)[5, :B] == 0
   end
   println(&quot;The production schedule is:&quot;)
   println(value.(production))
   return
end

example_factory_schedule()</code></pre><pre class="documenter-example-output">Test Summary:                            | Pass  Total
Check the solution against known optimal |    6      6
The production schedule is:
2-dimensional DenseAxisArray{Float64,2,...} with index sets:
    Dimension 1, 1:12
    Dimension 2, Symbol[:A, :B]
And data, a 12×2 Array{Float64,2}:
  70000.0   50000.0
  45000.0   55000.0
  70000.0   60000.0
  30000.0  100000.0
 140000.0       0.0
  60000.0   70000.0
  90000.0   60000.0
  70000.0  100000.0
 100000.0  100000.0
 190000.0       0.0
  80000.0   60000.0
 100000.0       0.0</pre><h2 id="The-multi-commodity-flow-problem"><a class="docs-heading-anchor" href="#The-multi-commodity-flow-problem">The multi-commodity flow problem</a><a id="The-multi-commodity-flow-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-multi-commodity-flow-problem" title="Permalink"></a></h2><p>JuMP implementation of the multicommodity transportation model AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan 4-1.</p><p>Originally contributed by Louis Luangkesorn, February 26, 2015.</p><pre><code class="language-julia">using JuMP
import GLPK
import Test

function example_multi(; verbose = true)
    orig = [&quot;GARY&quot;, &quot;CLEV&quot;, &quot;PITT&quot;]
    dest = [&quot;FRA&quot;, &quot;DET&quot;, &quot;LAN&quot;, &quot;WIN&quot;, &quot;STL&quot;, &quot;FRE&quot;, &quot;LAF&quot;]
    prod = [&quot;bands&quot;, &quot;coils&quot;, &quot;plate&quot;]
    numorig = length(orig)
    numdest = length(dest)
    numprod = length(prod)
    # supply(prod, orig) amounts available at origins
    supply = [
        400    700    800;
        800   1600   1800;
        200    300    300
    ]
    # demand(prod, dest) amounts required at destinations
    demand = [
        300   300   100    75   650   225   250;
        500   750   400   250   950   850   500;
        100   100     0    50   200   100   250
    ]
    # limit(orig, dest) of total units from any origin to destination
    limit = [625.0 for j in 1:numorig, i in 1:numdest]
    # cost(dest, orig, prod) Shipment cost per unit
    cost = reshape([
        [
            [  30,   10,    8,   10,   11,   71,    6];
            [  22,    7,   10,    7,   21,   82,   13];
            [  19,   11,   12,   10,   25,   83,   15]
        ];
        [
            [  39,   14,   11,   14,   16,   82,    8];
            [  27,    9,   12,    9,   26,   95,   17];
            [  24,   14,   17,   13,   28,   99,   20]
        ];
        [
            [  41,   15,   12,   16,   17,   86,    8];
            [  29,    9,   13,    9,   28,   99,   18];
            [  26,   14,   17,   13,   31,  104,   20]
        ]
    ], 7, 3, 3)
    # DECLARE MODEL
    multi = Model(GLPK.Optimizer)
    # VARIABLES
    @variable(multi, trans[1:numorig, 1:numdest, 1:numprod] &gt;= 0)
    # OBJECTIVE
    @objective(
        multi,
        Max,
        sum(
            cost[j, i, p] * trans[i, j, p]
            for i in 1:numorig, j in 1:numdest, p in 1:numprod
        )
    )
    # CONSTRAINTS
    # Supply constraint
    @constraint(
        multi,
        supply_con[i in 1:numorig, p in 1:numprod],
        sum(trans[i, j, p] for j in 1:numdest) == supply[p, i]
    )
    # Demand constraint
    @constraint(
        multi,
        demand_con[j in 1:numdest, p in 1:numprod],
        sum(trans[i, j, p] for i in 1:numorig) == demand[p, j]
    )
    # Total shipment constraint
    @constraint(
        multi,
        total_con[i in 1:numorig, j in 1:numdest],
        sum(trans[i, j, p] for p in 1:numprod) - limit[i, j] &lt;= 0
    )
    optimize!(multi)
    Test.@test termination_status(multi) == MOI.OPTIMAL
    Test.@test primal_status(multi) == MOI.FEASIBLE_POINT
    Test.@test objective_value(multi) == 225_700.0
    if verbose
        println(&quot;RESULTS:&quot;)
        for i in 1:length(orig)
            for j in 1:length(dest)
                for p in 1:length(prod)
                    print(&quot; $(prod[p]) $(orig[i]) $(dest[j]) = $(value(trans[i, j, p]))\t&quot;)
                end
                println()
            end
        end
    end
    return
end

example_multi()</code></pre><pre class="documenter-example-output">RESULTS:
 bands GARY FRA = 25.0	 coils GARY FRA = 500.0	 plate GARY FRA = 100.0
 bands GARY DET = 125.0	 coils GARY DET = 0.0	 plate GARY DET = 50.0
 bands GARY LAN = 0.0	 coils GARY LAN = 0.0	 plate GARY LAN = 0.0
 bands GARY WIN = 0.0	 coils GARY WIN = 0.0	 plate GARY WIN = 50.0
 bands GARY STL = 250.0	 coils GARY STL = 300.0	 plate GARY STL = 0.0
 bands GARY FRE = 0.0	 coils GARY FRE = 0.0	 plate GARY FRE = 0.0
 bands GARY LAF = 0.0	 coils GARY LAF = 0.0	 plate GARY LAF = 0.0
 bands CLEV FRA = 275.0	 coils CLEV FRA = 0.0	 plate CLEV FRA = 0.0
 bands CLEV DET = 100.0	 coils CLEV DET = 200.0	 plate CLEV DET = 50.0
 bands CLEV LAN = 100.0	 coils CLEV LAN = 0.0	 plate CLEV LAN = 0.0
 bands CLEV WIN = 0.0	 coils CLEV WIN = 75.0	 plate CLEV WIN = 0.0
 bands CLEV STL = 0.0	 coils CLEV STL = 625.0	 plate CLEV STL = 0.0
 bands CLEV FRE = 225.0	 coils CLEV FRE = 325.0	 plate CLEV FRE = 0.0
 bands CLEV LAF = 0.0	 coils CLEV LAF = 375.0	 plate CLEV LAF = 250.0
 bands PITT FRA = 0.0	 coils PITT FRA = 0.0	 plate PITT FRA = 0.0
 bands PITT DET = 75.0	 coils PITT DET = 550.0	 plate PITT DET = 0.0
 bands PITT LAN = 0.0	 coils PITT LAN = 400.0	 plate PITT LAN = 0.0
 bands PITT WIN = 75.0	 coils PITT WIN = 175.0	 plate PITT WIN = 0.0
 bands PITT STL = 400.0	 coils PITT STL = 25.0	 plate PITT STL = 200.0
 bands PITT FRE = 0.0	 coils PITT FRE = 525.0	 plate PITT FRE = 100.0
 bands PITT LAF = 250.0	 coils PITT LAF = 125.0	 plate PITT LAF = 0.0</pre><h2 id="The-workforce-scheduling-problem"><a class="docs-heading-anchor" href="#The-workforce-scheduling-problem">The workforce scheduling problem</a><a id="The-workforce-scheduling-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-workforce-scheduling-problem" title="Permalink"></a></h2><p>This model determines a set of workforce levels that will most economically meet demands and inventory requirements over time. The formulation is motivated by the experiences of a large producer in the United States. The data are for three products and 13 periods.</p><p>Problem taken from the Appendix C of the expanded version of Fourer, Gay, and Kernighan, A Modeling Language for Mathematical Programming</p><p>Originally contributed by Louis Luangkesorn, February 26, 2015.</p><pre><code class="language-julia">function example_prod(; verbose = true)
    # PRODUCTION SETS AND PARAMETERS
    prd = [&quot;18REG&quot;  &quot;24REG&quot; &quot;24PRO&quot;]
    # Members of the product group
    numprd = length(prd)
    pt =	[1.194,	1.509,	1.509]
    # Crew-hours to produce 1000 units
    pc =	[2304,	2920,	2910]
    # Nominal production cost per 1000, used
    # to compute inventory and shortage costs
    #
    # TIME PERIOD SETS AND PARAMETERS
    firstperiod = 1
    # Index of first production period to be modeled
    lastperiod  = 13
    # Index of last production period to be modeled
    numperiods = firstperiod:lastperiod
    # &#39;planning horizon&#39; := first..last;
    # EMPLOYMENT PARAMETERS
    # Workers per crew
    cs = 18
    # Regular-time hours per shift
    sl =  8
    # Wage per hour for regular-time labor
    rtr = 16.00
    # Wage per hour for overtime labor
    otr = 43.85
    # Crews employed at start of first period
    iw =  8
    # Regular working days in a production period
    dpp =	 [19.5,	19,	20,	19,	19.5,	19,	19,	20,	19,	20,	20,	18,	18]
    # Maximum crew-hours of overtime in a period
    ol =	 [96,	96,	96,	96,	96,	96,	96,	96,	96,	96,	96,	96,	96]
    # Lower limit on average employment in a period
    cmin =	[0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0]
    # Upper limit on average employment in a period
    cmax =	[8,	8,	8,	8,	8,	8,	8,	8,	8,	8,	8,	8,	8]
    # Penalty cost of hiring a crew
    hc =	 [7500,	7500,	7500,	7500,	15000,	15000,	15000,	15000,	15000,	15000,	7500,	7500,	7500]
    # Penalty cost of laying off a crew
    lc =	 [7500,	7500,	7500,	7500,	15000,	15000,	15000,	15000,	15000,	15000,	7500,	7500,	7500]
    # DEMAND PARAMETERS
    d18REG = [63.8,	76,	88.4,	913.8,	115,	133.8,	79.6,	111,	121.6,	470,	78.4,	99.4,	140.4,	63.8]
    d24REG = [1212,	306.2,	319,	208.4,	298,	328.2,	959.6,	257.6,	335.6,	118,	284.8,	970,	343.8,	1212]
    d24PRO = [0,	0,	0,	0,	0,	0,	0,	0,	0,	1102,	0,	0,	0,	0]
    # Requirements (in 1000s) to be met from current production and inventory
    dem = Array[d18REG, d24REG, d24PRO]
    # true if product will be the subject of a special promotion in the period
    pro = Array[
        [0,	0,	0,	1,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0],
        [1,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	1,	1],
        [0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0],
    ]
    # INVENTORY AND SHORTAGE PARAMETERS
    # Proportion of non-promoted demand that must be in inventory the previous
    # period
    rir = 0.75
    # Proportion of promoted demand that must be in inventory the previous
    # period
    pir = 0.80
    # Upper limit on number of periods that any product may sit in inventory
    life = 2
    # Inventory cost per 1000 units is cri times nominal production cost
    cri	= [0.015,	0.015,	0.015]
    # Shortage cost per 1000 units is crs times nominal production cost
    crs	= [1.1,	1.1,	1.1]
    # Inventory at start of first period; age unknown
    iinv = [82,	792.2,	0]
    # Initial inventory still available for allocation at end of period t
    iil = [
        [
            max(0, iinv[p] - sum(dem[p][v] for v in firstperiod:t))
            for t in numperiods
        ]
        for p in 1:numprd
    ]
    # Lower limit on inventory at end of period t
    function checkpro(
        product, timeperiod, production, promotionalrate, regularrate
    )
        if production[product][timeperiod + 1] == 1
            return promotionalrate
        else
            return regularrate
        end
    end
    minv = [
        [dem[p][t + 1] * checkpro(p, t, pro, pir, rir) for t in numperiods]
        for p in 1:numprd
    ]
    # DEFINE MODEL
    prod = Model(GLPK.Optimizer)
    # VARIABLES
    # Average number of crews employed in each period
    @variable(prod, Crews[0:lastperiod] &gt;= 0)
    # Crews hired from previous to current period
    @variable(prod, Hire[numperiods] &gt;= 0)
    # Crews laid off from previous to current period
    @variable(prod, Layoff[numperiods]&gt;= 0)
    # Production using regular-time labor, in 1000s
    @variable(prod, Rprd[1:numprd, numperiods] &gt;= 0)
    # Production using overtime labor, in 1000s
    @variable(prod, Oprd[1:numprd, numperiods]&gt;= 0)
    # a numperiods old -- produced in period (t+1)-a --
    # and still in storage at the end of period t
    @variable(prod, Inv[1:numprd, numperiods, 1:life] &gt;= 0)
    # Accumulated unsatisfied demand at the end of period t
    @variable(prod, Short[1:numprd, numperiods] &gt;= 0)
    # CONSTRAINTS
    # Hours needed to accomplish all regular-time production in a period must
    # not exceed hours available on all shifts
    @constraint(
        prod,
        [t = numperiods],
        sum(pt[p] * Rprd[p, t] for p in 1:numprd) &lt;= sl * dpp[t] * Crews[t]
    )
    # Hours needed to accomplish all overtime production in a period must not
    # exceed the specified overtime limit
    @constraint(
        prod,
        [t = numperiods],
        sum(pt[p] * Oprd[p, t] for p in 1:numprd)  &lt;= ol[t]
    )
    # Use given initial workforce
    @constraint(prod, Crews[firstperiod - 1] == iw)
    # Workforce changes by hiring or layoffs
    @constraint(
        prod, [t in numperiods], Crews[t] == Crews[t - 1] + Hire[t] - Layoff[t]
    )
    # Workforce must remain within specified bounds
    @constraint(prod, [t in numperiods], cmin[t] &lt;= Crews[t])
    @constraint(prod, [t in numperiods], Crews[t] &lt;= cmax[t])
    # &#39;first demand requirement
    @constraint(
        prod,
        [p in 1:numprd],
        Rprd[p, firstperiod] + Oprd[p, firstperiod] + Short[p, firstperiod] -
            Inv[p, firstperiod, 1] == max(0, dem[p][firstperiod] - iinv[p])
    )
    # Production plus increase in shortage plus decrease in inventory must
    # equal demand
    for t in (firstperiod + 1):lastperiod
        @constraint(
            prod,
            [p in 1:numprd],
            Rprd[p, t] + Oprd[p, t] + Short[p,t] - Short[p,t-1] +
                sum(Inv[p, t - 1, a] - Inv[p, t, a] for a in 1:life) ==
                max(0, dem[p][t] - iil[p][t - 1])
        )
    end
    # Inventory in storage at end of period t must meet specified minimum
    @constraint(
        prod,
        [p in 1:numprd, t in numperiods],
        sum(Inv[p, t, a] + iil[p][t] for a in 1:life) &gt;= minv[p][t]
    )
    # In the vth period (starting from first) no inventory may be more than v
    # numperiods old (initial inventories are handled separately)
    @constraint(
        prod,
        [p in 1:numprd, v in 1:(life - 1), a in (v + 1):life],
        Inv[p, firstperiod + v - 1, a] == 0
    )
    # New inventory cannot exceed production in the most recent period
    @constraint(
        prod,
        [p in 1:numprd, t in numperiods],
        Inv[p, t, 1] &lt;= Rprd[p, t] + Oprd[p, t]
    )
    # Inventory left from period (t+1)-p can only decrease as time goes on
    secondperiod = firstperiod + 1
    @constraint(
        prod,
        [p in 1:numprd, t in 2:lastperiod, a in 2:life],
        Inv[p, t, a] &lt;= Inv[p, t - 1, a - 1]
    )
    # OBJECTIVE
    # Full regular wages for all crews employed, plus penalties for hiring and
    # layoffs, plus wages for any overtime worked, plus inventory and shortage
    # costs. (All other production costs are assumed to depend on initial
    # inventory and on demands, and so are not included explicitly.)
    @objective(
        prod,
        Min,
        sum(
            rtr * sl * dpp[t] * cs * Crews[t] +
            hc[t] * Hire[t] +
            lc[t] * Layoff[t] +
            sum(
                otr * cs * pt[p] * Oprd[p, t] +
                sum(cri[p] * pc[p] * Inv[p, t, a] for a in 1:life) +
                crs[p] * pc[p] * Short[p, t]
                for p in 1:numprd
            )
           for t in numperiods
        )
    )
    # Obtain solution
    optimize!(prod)
    Test.@test termination_status(prod) == MOI.OPTIMAL
    Test.@test primal_status(prod) == MOI.FEASIBLE_POINT
    Test.@test objective_value(prod) ≈ 4_426_822.89 atol = 1e-2
    if verbose
        println(&quot;RESULTS:&quot;)
        println(&quot;Crews&quot;)
        for t = 0:length(Crews.data) - 1
            print(&quot; $(value(Crews[t])) &quot;)
        end
        println()
        println(&quot;Hire&quot;)
        for t = 1:length(Hire.data)
            print(&quot; $(value(Hire[t])) &quot;)
        end
        println()
        println(&quot;Layoff&quot;)
        for t = 1:length(Layoff.data)
            print(&quot; $(value(Layoff[t])) &quot;)
        end
        println()
    end
    return
end

example_prod()</code></pre><pre class="documenter-example-output">RESULTS:
Crews
 8.0  6.439849038461538  5.947339134615386  5.947339134615383  5.947339134615383  5.947339134615383  6.162946095647776  6.3400572039473655  7.805664375000001  7.805664375000001  7.805664375000001  7.805664375000001  8.0  8.0
Hire
 0.0  0.0  0.0  0.0  0.0  0.21560696103239252  0.17711110829958976  1.4656071710526355  0.0  0.0  0.0  0.194335624999999  0.0
Layoff
 1.5601509615384623  0.4925099038461518  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</pre><h2 id="Solving-Sudokus-with-MIP"><a class="docs-heading-anchor" href="#Solving-Sudokus-with-MIP">Solving Sudokus with MIP</a><a id="Solving-Sudokus-with-MIP-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-Sudokus-with-MIP" title="Permalink"></a></h2><p>A sudoku solver that uses a MIP to find solutions.</p><p>We have binary variables <code>x[i, j, k]</code> which, if = 1, say that cell (i, j) contains the number k. The constraints are:  1 - Each cell has one value only  2 - Each row contains each number exactly once  3 - Each column contains each number exactly once  4 - Each 3x3 subgrid contains each number exactly once We will take the initial grid as a CSV file at <code>filepath</code>, where 0s are blanks.</p><pre><code class="language-julia">using JuMP
import GLPK
import Test

function example_sudoku(filepath::String)
    initial_grid = zeros(Int, 9, 9)
    open(filepath, &quot;r&quot;) do fp
        for row in 1:9
            line = readline(fp)
            initial_grid[row, :] .= parse.(Int, split(line, &quot;,&quot;))
        end
    end
    model = Model(GLPK.Optimizer)
    @variable(model, x[1:9, 1:9, 1:9], Bin)
    @constraints(model, begin
        # Constraint 1 - Only one value appears in each cell
        cell[i in 1:9, j in 1:9], sum(x[i, j, :]) == 1
        # Constraint 2 - Each value appears in each row once only
        row[i in 1:9, k in 1:9], sum(x[i, :, k]) == 1
        # Constraint 3 - Each value appears in each column once only
        col[j in 1:9, k in 1:9], sum(x[:, j, k]) == 1
        # Constraint 4 - Each value appears in each 3x3 subgrid once only
        subgrid[i=1:3:7, j=1:3:7, val=1:9], sum(x[i:i + 2, j:j + 2, val]) == 1
    end)
    # Initial solution
    for row in 1:9, col in 1:9
        if initial_grid[row, col] != 0
            fix(x[row, col, initial_grid[row, col]], 1)
        end
    end
    # Solve it
    optimize!(model)
    # Check solution
    term_status = termination_status(model)
    is_optimal = term_status == MOI.OPTIMAL
    if is_optimal
        mip_solution = value.(x)
        sol = zeros(Int, 9, 9)
        for row in 1:9, col in 1:9, val in 1:9
            if mip_solution[row, col, val] &gt;= 0.9
                sol[row, col] = val
            end
        end
        return sol
    else
        error(&quot;The solver did not find an optimal solution.&quot;)
    end
end</code></pre><pre class="documenter-example-output">example_sudoku (generic function with 1 method)</pre><p>Create an initial file. We could have set the <code>example_sudoku</code> function to take a matrix as input, but this example shows Julia&#39;s ability to parse files.</p><pre><code class="language-julia">open(&quot;sudoku.csv&quot;, &quot;w&quot;) do io
    write(io, &quot;&quot;&quot;
    3, 1, 0, 0, 5, 8, 0, 0, 4
    0, 0, 9, 3, 2, 0, 0, 0, 0
    0, 2, 5, 1, 0, 4, 0, 9, 0
    0, 0, 0, 0, 0, 0, 3, 8, 9
    0, 0, 8, 0, 0, 0, 5, 0, 0
    5, 4, 6, 0, 0, 0, 0, 0, 0
    0, 8, 0, 2, 0, 3, 6, 5, 0
    0, 0, 0, 0, 7, 1, 4, 0, 0
    7, 0, 0, 4, 8, 0, 0, 2, 1
    &quot;&quot;&quot;)
end</code></pre><pre class="documenter-example-output">234</pre><p>Now try solving the example:</p><pre><code class="language-julia">solution = example_sudoku(&quot;sudoku.csv&quot;)

Test.@test solution == [
    3 1 7 9 5 8 2 6 4;
    4 6 9 3 2 7 8 1 5;
    8 2 5 1 6 4 7 9 3;
    2 7 1 6 4 5 3 8 9;
    9 3 8 7 1 2 5 4 6;
    5 4 6 8 3 9 1 7 2;
    1 8 4 2 9 3 6 5 7;
    6 9 2 5 7 1 4 3 8;
    7 5 3 4 8 6 9 2 1
]</code></pre><pre class="documenter-example-output">Test Passed</pre><p>The matrix can be hard to read. Print the solution properly:</p><pre><code class="language-julia">function print_sudoku_solution(solution)
    println(&quot;Solution:&quot;)
    println(&quot;[-----------------------]&quot;)
    for row in 1:9
        print(&quot;[ &quot;)
        for col in 1:9
            print(solution[row, col], &quot; &quot;)
            if col % 3 == 0 &amp;&amp; col &lt; 9
                print(&quot;| &quot;)
            end
        end
        println(&quot;]&quot;)
        if row % 3 == 0
            println(&quot;[-----------------------]&quot;)
        end
    end
end

print_sudoku_solution(solution)</code></pre><pre class="documenter-example-output">Solution:
[-----------------------]
[ 3 1 7 | 9 5 8 | 2 6 4 ]
[ 4 6 9 | 3 2 7 | 8 1 5 ]
[ 8 2 5 | 1 6 4 | 7 9 3 ]
[-----------------------]
[ 2 7 1 | 6 4 5 | 3 8 9 ]
[ 9 3 8 | 7 1 2 | 5 4 6 ]
[ 5 4 6 | 8 3 9 | 1 7 2 ]
[-----------------------]
[ 1 8 4 | 2 9 3 | 6 5 7 ]
[ 6 9 2 | 5 7 1 | 4 3 8 ]
[ 7 5 3 | 4 8 6 | 9 2 1 ]
[-----------------------]</pre><p>Clean up the file we made:</p><pre><code class="language-julia">rm(&quot;sudoku.csv&quot;)</code></pre><p><a href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/mixed-integer-linear-programs.jl">View this file on Github</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cutting_stock_column_generation/">« Cutting stock column generation</a><a class="docs-footer-nextpage" href="../nlp_tricks/">Nonlinear tips and tricks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 31 January 2021 23:38">Sunday 31 January 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
